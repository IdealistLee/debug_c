#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import sys

def process_amplitude_file(input_file, output_file):
    """
    处理AMPLITUDE文本文件
    只修改数字部分，其他格式保持不变
    """
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"错误：找不到输入文件 '{input_file}'")
        return False
    except Exception as e:
        print(f"读取文件时出错：{e}")
        return False
    
    # 使用正则表达式匹配和处理
    pattern = r'(\*AMPLITUDE[^\n]*_1, DEFINITION = TABULAR\s*)((?:[0-9.-][^\n]*\s*)*)'
    
    def replace_numbers(match):
        header = match.group(1)  # 保持头部不变
        data_lines = match.group(2).strip().split('\n')
        
        processed_lines = []
        for line in data_lines:
            line = line.strip()
            if not line or line.startswith('*'):
                processed_lines.append(line)
                continue
                
            # 分割逗号前后的部分
            parts = line.split(',', 1)
            if len(parts) == 2:
                try:
                    # 只修改第一个数字，保持原有格式
                    first_num = float(parts[0].strip())
                    first_num += 10.001
                    
                    # 保持原有格式，只替换数字
                    # 使用原有空格和格式
                    first_part = parts[0].rstrip()
                    # 找到数字前的空格
                    num_match = re.search(r'(-?\d+\.?\d*)', first_part)
                    if num_match:
                        # 替换数字部分，保持原有格式
                        new_first_part = first_part.replace(num_match.group(1), f"{first_num:.6f}")
                        processed_lines.append(new_first_part + ',' + parts[1])
                    else:
                        # 如果没有找到数字，使用默认格式
                        processed_lines.append(f"{first_num:10.6f} ,{parts[1]}")
                except ValueError:
                    processed_lines.append(line)
            else:
                processed_lines.append(line)
        
        return header + '\n'.join(processed_lines) + ('\n' if data_lines else '')
    
    # 应用替换
    processed_content = re.sub(pattern, replace_numbers, content, flags=re.DOTALL)
    
    # 写入输出文件
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(processed_content)
        print(f"处理完成！输出文件：{output_file}")
        return True
    except Exception as e:
        print(f"写入文件时出错：{e}")
        return False

def process_amplitude_file_improved(input_file, output_file):
    """
    改进版本：更精确地保持原始格式
    """
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f"错误：找不到输入文件 '{input_file}'")
        return False
    except Exception as e:
        print(f"读取文件时出错：{e}")
        return False
    
    processed_lines = []
    i = 0
    n = len(lines)
    in_target_block = False
    
    while i < n:
        line = lines[i]
        
        # 检查是否是AMPLITUDE行
        if line.startswith('*AMPLITUDE'):
            # 检查是否以"_1, DEFINITION = TABULAR"结尾
            if '_1, DEFINITION = TABULAR' in line:
                in_target_block = True
            else:
                in_target_block = False
            
            processed_lines.append(line)
            i += 1
            continue
        
        # 如果在目标块中且是数据行
        if in_target_block and not line.startswith('*') and line.strip():
            # 尝试解析数据行
            parts = line.split(',', 1)
            if len(parts) == 2:
                # 提取第一个数字
                first_part = parts[0].strip()
                try:
                    first_num = float(first_part)
                    first_num += 10.001
                    
                    # 保持原始格式，只替换数字
                    # 找到数字在字符串中的位置
                    num_match = re.search(r'(-?\d+\.?\d*)', parts[0])
                    if num_match:
                        # 替换数字，保持原有空格
                        start, end = num_match.span()
                        new_first_part = parts[0][:start] + f"{first_num:.6f}" + parts[0][end:]
                        processed_lines.append(new_first_part + ',' + parts[1])
                    else:
                        # 如果没有匹配到数字格式，使用默认处理
                        processed_lines.append(f"{first_num:10.6f} ,{parts[1]}")
                except ValueError:
                    # 如果转换失败，保留原行
                    processed_lines.append(line)
            else:
                processed_lines.append(line)
        else:
            processed_lines.append(line)
        
        i += 1
    
    # 写入输出文件
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.writelines(processed_lines)
        print(f"处理完成！输出文件：{output_file}")
        return True
    except Exception as e:
        print(f"写入文件时出错：{e}")
        return False

def main():
    """
    主函数
    """
    print("=" * 50)
    print("AMPLITUDE文本处理工具")
    print("=" * 50)
    print("功能：处理以*AMPLITUDE开头的文本文件")
    print("对于以'_1, DEFINITION = TABULAR'结尾的块，")
    print("将其后的所有数据行的第一个数字加10.001")
    print("并尽量保持原始格式")
    print("=" * 50)
    
    if len(sys.argv) == 3:
        # 命令行参数模式
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        process_amplitude_file_improved(input_file, output_file)
    else:
        # 交互模式
        input_file = input("请输入输入文件名（例如：input.txt）: ").strip()
        if not input_file:
            print("文件名不能为空！")
            return
        
        output_file = input("请输入输出文件名（例如：output.txt）: ").strip()
        if not output_file:
            print("文件名不能为空！")
            return
        
        process_amplitude_file_improved(input_file, output_file)

if __name__ == "__main__":
    main()
